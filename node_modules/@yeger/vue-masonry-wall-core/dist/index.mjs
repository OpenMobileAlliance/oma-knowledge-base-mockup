const S = {
  columnWidth: 400,
  gap: 0,
  keyMapper: (u, a, v, l) => l,
  minColumns: 1,
  maxColumns: void 0,
  rtl: !1,
  scrollContainer: null,
  ssrColumns: 0
};
function j({
  columns: u,
  columnWidth: a,
  emit: v,
  gap: l,
  items: g,
  maxColumns: c,
  minColumns: f,
  nextTick: _,
  onBeforeUnmount: k,
  onMounted: A,
  rtl: y,
  scrollContainer: w,
  ssrColumns: h,
  vue: Y,
  wall: s,
  watch: p
}) {
  function R(t, e, n, o) {
    const i = T(n);
    return o + e + i <= t ? R(
      t,
      e,
      n + 1,
      o + e + i
    ) : n;
  }
  function T(t) {
    const e = Array.isArray(a.value) ? a.value : [a.value];
    return e[t % e.length];
  }
  function b() {
    const t = R(
      s.value.getBoundingClientRect().width,
      l.value,
      0,
      // Needs to be offset my negative gap to prevent gap counts being off by one
      -l.value
    ), e = E(D(t));
    return e > 0 ? e : 1;
  }
  function D(t) {
    const e = c == null ? void 0 : c.value;
    return e && t > e ? e : t;
  }
  function E(t) {
    const e = f == null ? void 0 : f.value;
    return e && t < e ? e : t;
  }
  function B(t) {
    return Array.from({ length: t }).map(() => []);
  }
  if (h.value > 0) {
    const t = B(h.value);
    g.value.forEach(
      (e, n) => t[n % h.value].push(n)
    ), u.value = t;
  }
  async function M(t) {
    if (t >= g.value.length)
      return;
    await _();
    const e = [...s.value.children];
    y.value && e.reverse();
    const n = e.reduce(
      (o, i) => i.getBoundingClientRect().height < o.getBoundingClientRect().height ? i : o
    );
    u.value[+n.dataset.index].push(t), await M(t + 1);
  }
  async function d(t = !1) {
    if (u.value.length === b() && !t) {
      v(Y === 2 ? "redraw-skip" : "redrawSkip");
      return;
    }
    u.value = B(b());
    const e = w == null ? void 0 : w.value, n = e ? e.scrollTop : window.scrollY;
    await M(0), e ? e.scrollBy({ top: n - e.scrollTop }) : window.scrollTo({ top: n }), v("redraw");
  }
  const r = typeof ResizeObserver > "u" ? void 0 : new ResizeObserver(() => d());
  return A(() => {
    d(), r == null || r.observe(s.value);
  }), k(() => r == null ? void 0 : r.unobserve(s.value)), p([g, y], () => d(!0)), p([a, l, f, c], () => d()), { getColumnWidthTarget: T };
}
export {
  S as defaults,
  j as useMasonryWall
};
