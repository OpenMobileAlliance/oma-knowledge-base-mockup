import { defineComponent as Q, toRefs as se, openBlock as d, createElementBlock as P, createElementVNode as j, ref as I, inject as _, provide as Y, onMounted as ge, nextTick as me, onBeforeUnmount as We, unref as l, createBlock as O, normalizeClass as Z, renderSlot as F, mergeProps as xe, createCommentVNode as A, createVNode as le, toDisplayString as ke, Transition as Ee, normalizeProps as Ge, withCtx as ce, resolveComponent as de, normalizeStyle as Be, Fragment as Ie, renderList as De, createSlots as qe, withDirectives as Ae, vShow as He, useSlots as Je, watch as Te, h as ue, Teleport as Qe, render as je } from "vue";
let G = null;
function en() {
  return G !== null;
}
function nn(e) {
  G && Ne(), G = e;
}
function Fe(e) {
  e === G && (G = null);
}
function Ne() {
  G && (G.closeMenu(), G = null);
}
const N = {
  defaultDirection: "br",
  defaultMinWidth: 100,
  defaultMaxWidth: 600,
  defaultZindex: 100,
  defaultZoom: 1,
  defaultAdjustPadding: {
    x: 0,
    y: 10
  }
};
function q(e, n) {
  let s = e.offsetTop;
  return e.offsetParent != null && e.offsetParent != n && (s -= e.offsetParent.scrollTop, s += q(e.offsetParent, n)), s;
}
function J(e, n) {
  let s = e.offsetLeft;
  return e.offsetParent != null && e.offsetParent != n && (s -= e.offsetParent.scrollLeft, s += J(e.offsetParent, n)), s;
}
function tn(e, n, s, r) {
  return {
    x: J(e, r) + n,
    y: q(e, r) + s
  };
}
const Se = "mx-menu-default-container", on = "mx-menu-container-";
let ln = 0;
function ze(e) {
  const { getContainer: n, zIndex: s } = e;
  if (n) {
    const f = typeof n == "function" ? n() : n;
    if (f) {
      let v = f.getAttribute("id");
      return v || (v = on + ln++, f.setAttribute("id", v)), {
        eleId: v,
        container: f,
        isNew: !1
      };
    }
  }
  let r = document.getElementById(Se);
  return r || (r = document.createElement("div"), r.setAttribute("id", Se), r.setAttribute("class", "mx-menu-ghost-host fullscreen"), document.body.appendChild(r)), r.style.zIndex = (s == null ? void 0 : s.toString()) || N.defaultZindex.toString(), {
    eleId: Se,
    container: r,
    isNew: !0
  };
}
function un(e) {
  return typeof e == "number" ? `${e}px` : e;
}
const V = Q({
  props: {
    /**
     * Can be VNode or (data: unknown) => VNode
     */
    vnode: {
      type: null
    },
    /**
     * If vnode is a callback, this data will be passed to the callback first parameter.
     * @default null
     */
    data: {
      type: null,
      default: null
    }
  },
  setup(e) {
    const { vnode: n, data: s } = se(e);
    return () => typeof n.value == "function" ? n.value(s.value) : n.value;
  }
}), fe = (e, n) => {
  const s = e.__vccOpts || e;
  for (const [r, f] of n)
    s[r] = f;
  return s;
}, sn = {}, an = {
  class: "mx-checked-mark",
  "aria-hidden": "true",
  viewBox: "0 0 1024 1024"
}, rn = /* @__PURE__ */ j("path", { d: "M129.3,428.6L52,512l345,372.5l575-620.8l-69.5-75L400.4,718.2L129.3,428.6z" }, null, -1), dn = [
  rn
];
function cn(e, n) {
  return d(), P("svg", an, dn);
}
const fn = /* @__PURE__ */ fe(sn, [["render", cn]]), vn = {}, hn = {
  class: "mx-right-arrow",
  "aria-hidden": "true",
  viewBox: "0 0 1024 1024"
}, mn = /* @__PURE__ */ j("path", { d: "M307.018 49.445c11.517 0 23.032 4.394 31.819 13.18L756.404 480.18c8.439 8.438 13.181 19.885 13.181 31.82s-4.741 23.38-13.181 31.82L338.838 961.376c-17.574 17.573-46.065 17.573-63.64-0.001-17.573-17.573-17.573-46.065 0.001-63.64L660.944 512 275.198 126.265c-17.574-17.573-17.574-46.066-0.001-63.64C283.985 53.839 295.501 49.445 307.018 49.445z" }, null, -1), pn = [
  mn
];
function gn(e, n) {
  return d(), P("svg", hn, pn);
}
const Ve = /* @__PURE__ */ fe(vn, [["render", gn]]), bn = { class: "mx-item-row" }, Cn = ["xlink:href"], Mn = {
  key: 1,
  class: "label"
}, yn = { class: "mx-item-row" }, Sn = { class: "mx-shortcut" }, Pe = /* @__PURE__ */ Q({
  __name: "ContextMenuItem",
  props: {
    /**
     * Is this menu disabled? 
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Is this menu hidden? 
     */
    hidden: {
      type: Boolean,
      default: !1
    },
    customRender: {
      type: Function,
      default: null
    },
    /**
     * Custom css class for submenu
     */
    customClass: {
      type: String,
      default: ""
    },
    clickHandler: {
      type: Function,
      default: null
    },
    /**
     * Menu label
     */
    label: {
      type: [String, Object, Function],
      default: ""
    },
    /**
     * Menu icon (for icon class)
     */
    icon: {
      type: [String, Object, Function],
      default: ""
    },
    /**
     * Custom icon library font class name.
     * 
     * Only for css font icon, If you use the svg icon, you do not need to use this.
     */
    iconFontClass: {
      type: String,
      default: "iconfont"
    },
    /**
     * Is this menu item checked?
     * 
     * The check mark are displayed on the left side of the icon, so it is not recommended to display the icon at the same time.
     */
    checked: {
      type: Boolean,
      default: !1
    },
    /**
     * Shortcut key text display on the right.
     * 
     * The shortcut keys here are only for display. You need to handle the key events by yourself.
     */
    shortcut: {
      type: String,
      default: ""
    },
    /**
     * Display icons use svg symbol (`<use xlink:href="#icon-symbol-name">`) ， only valid when icon attribute is empty.
     */
    svgIcon: {
      type: String,
      default: ""
    },
    /**
     * The user-defined attribute of the svg tag, which is valid when using `svgIcon`.
     */
    svgProps: {
      type: Object,
      default: null
    },
    /**
     * Should a fixed-width icon area be reserved for menu items without icon. (this item)
     * 
     * Default is true .
     * 
     * The width of icon area can be override with css var `--mx-menu-placeholder-width`.
     */
    preserveIconWidth: {
      type: Boolean,
      default: !0
    },
    /**
     * Show right arrow on this menu?
     */
    showRightArrow: {
      type: Boolean,
      default: !1
    },
    hasChildren: {
      type: Boolean,
      default: !1
    },
    /**
     * Should close menu when Click this menu item ?
     */
    clickClose: {
      type: Boolean,
      default: !0
    },
    /**
     * When there are subitems in this item, is it allowed to trigger its own click event? Default is false
     */
    clickableWhenHasChildren: {
      type: Boolean,
      default: !1
    },
    rawMenuItem: {
      type: Object,
      default: void 0
    }
  },
  emits: [
    "click",
    "subMenuOpen",
    "subMenuClose"
  ],
  setup(e, { expose: n, emit: s }) {
    const r = e, f = s, {
      clickHandler: v,
      clickClose: S,
      clickableWhenHasChildren: i,
      disabled: m,
      hidden: b,
      label: t,
      icon: x,
      iconFontClass: $,
      showRightArrow: w,
      shortcut: E,
      hasChildren: L
    } = se(r), M = I(!1), o = I(!1), a = I(), g = _("globalOptions"), C = _("globalHasSlot"), R = _("globalRenderSlot"), c = _("globalCloseMenu"), y = _("menuContext"), W = {
      getSubMenuInstance: () => {
      },
      showSubMenu: () => M.value ? (y.markActiveMenuItem(W, !0), !0) : L.value ? (z(), !0) : !1,
      hideSubMenu: () => {
        y.closeOtherSubMenu();
      },
      isDisabledOrHidden: () => m.value || b.value,
      getElement: () => a.value,
      focus: () => o.value = !0,
      blur: () => o.value = !1,
      click: D
    };
    Y("menuItemInstance", W), ge(() => {
      y.isMenuItemDataCollectedFlag() ? me(() => {
        let p = 0;
        const B = y.getElement();
        if (B) {
          let K = 0;
          for (let X = 0; X < B.children.length; X++) {
            const ne = B.children[X];
            if (ne.getAttribute("data-type") === "ContextMenuItem") {
              if (ne === a.value) {
                p = K;
                break;
              }
              K++;
            }
          }
        }
        y.addChildMenuItem(W, p);
      }) : y.addChildMenuItem(W);
    }), We(() => {
      y.removeChildMenuItem(W);
    });
    function D(p) {
      if (!m.value) {
        if (p) {
          const B = p.target;
          if (B.classList.contains("mx-context-no-clickable") || g.value.ignoreClickClassName && B.classList.contains(g.value.ignoreClickClassName))
            return;
          if (g.value.clickCloseClassName && B.classList.contains(g.value.clickCloseClassName)) {
            p.stopPropagation(), c(r.rawMenuItem);
            return;
          }
        }
        L.value ? i.value ? (typeof v.value == "function" && v.value(p), f("click", p)) : M.value || z() : (typeof v.value == "function" && v.value(p), f("click", p), S.value && c(r.rawMenuItem));
      }
    }
    function z(p) {
      o.value = !1, y.checkCloseOtherSubMenuTimeOut() || y.closeOtherSubMenu(), m.value || (y.markActiveMenuItem(W), L.value && (p || y.markThisOpenedByKeyBoard(), y.addOpenedSubMenu(ee), M.value = !0, me(() => f("subMenuOpen", W))));
    }
    function ee() {
      o.value = !1, M.value = !1, f("subMenuClose", W);
    }
    function H() {
      return {
        disabled: m.value,
        label: t.value,
        icon: x.value,
        iconFontClass: $.value,
        showRightArrow: w.value,
        clickClose: S.value,
        clickableWhenHasChildren: i.value,
        shortcut: E.value,
        theme: g.value.theme,
        isOpen: M,
        hasChildren: L,
        onClick: D,
        onMouseEnter: z,
        closeMenu: c
      };
    }
    return n(W), (p, B) => l(b) ? A("", !0) : (d(), P("div", {
      key: 0,
      class: "mx-context-menu-item-wrapper",
      ref_key: "menuItemRef",
      ref: a,
      "data-type": "ContextMenuItem"
    }, [
      l(C)("itemRender") ? (d(), O(l(V), {
        key: 0,
        vnode: () => l(R)("itemRender", H())
      }, null, 8, ["vnode"])) : e.customRender ? (d(), O(l(V), {
        key: 1,
        vnode: e.customRender,
        data: H()
      }, null, 8, ["vnode", "data"])) : (d(), P("div", {
        key: 2,
        class: Z([
          "mx-context-menu-item",
          l(m) ? "disabled" : "",
          o.value ? "keyboard-focus" : "",
          e.customClass ? " " + e.customClass : "",
          M.value ? "open" : ""
        ]),
        onClick: D,
        onMouseenter: z
      }, [
        F(p.$slots, "default", {}, () => [
          j("div", bn, [
            j("div", {
              class: Z([
                "mx-icon-placeholder",
                e.preserveIconWidth ? "preserve-width" : ""
              ])
            }, [
              F(p.$slots, "icon", {}, () => [
                l(C)("itemIconRender") ? (d(), O(l(V), {
                  key: 0,
                  vnode: () => l(R)("itemIconRender", H())
                }, null, 8, ["vnode"])) : typeof e.svgIcon == "string" && e.svgIcon ? (d(), P("svg", xe({
                  key: 1,
                  class: "icon svg"
                }, e.svgProps), [
                  j("use", { "xlink:href": e.svgIcon }, null, 8, Cn)
                ], 16)) : typeof l(x) != "string" ? (d(), O(l(V), {
                  key: 2,
                  vnode: l(x),
                  data: l(x)
                }, null, 8, ["vnode", "data"])) : typeof l(x) == "string" && l(x) !== "" ? (d(), P("i", {
                  key: 3,
                  class: Z(l(x) + " icon " + l($) + " " + l(g).iconFontClass)
                }, null, 2)) : A("", !0)
              ]),
              e.checked ? F(p.$slots, "check", { key: 0 }, () => [
                l(C)("itemCheckRender") ? (d(), O(l(V), {
                  key: 0,
                  vnode: () => l(R)("itemCheckRender", H())
                }, null, 8, ["vnode"])) : A("", !0),
                le(fn)
              ]) : A("", !0)
            ], 2),
            F(p.$slots, "label", {}, () => [
              l(C)("itemLabelRender") ? (d(), O(l(V), {
                key: 0,
                vnode: () => l(R)("itemLabelRender", H())
              }, null, 8, ["vnode"])) : typeof l(t) == "string" ? (d(), P("span", Mn, ke(l(t)), 1)) : (d(), O(l(V), {
                key: 2,
                vnode: l(t),
                data: l(t)
              }, null, 8, ["vnode", "data"]))
            ])
          ]),
          j("div", yn, [
            l(E) ? F(p.$slots, "shortcut", { key: 0 }, () => [
              l(C)("itemShortcutRender") ? (d(), O(l(V), {
                key: 0,
                vnode: () => l(R)("itemShortcutRender", H())
              }, null, 8, ["vnode"])) : A("", !0),
              j("span", Sn, ke(l(E)), 1)
            ]) : A("", !0),
            l(w) ? F(p.$slots, "rightArrow", { key: 1 }, () => [
              l(C)("itemRightArrowRender") ? (d(), O(l(V), {
                key: 0,
                vnode: () => l(R)("itemRightArrowRender", H())
              }, null, 8, ["vnode"])) : A("", !0),
              le(Ve)
            ]) : A("", !0)
          ])
        ])
      ], 34)),
      l(g).menuTransitionProps ? (d(), O(Ee, Ge(xe({ key: 3 }, l(g).menuTransitionProps)), {
        default: ce(() => [
          M.value ? F(p.$slots, "submenu", { key: 0 }) : A("", !0)
        ]),
        _: 3
      }, 16)) : M.value ? F(p.$slots, "submenu", { key: 4 }) : A("", !0)
    ], 512));
  }
}), xn = Q({
  name: "ContextMenuSperator",
  components: {
    VNodeRender: V
  },
  setup() {
    const e = _("globalHasSlot"), n = _("globalRenderSlot");
    return {
      globalHasSlot: e,
      globalRenderSlot: n
    };
  }
}), kn = {
  key: 1,
  class: "mx-context-menu-item-sperator mx-context-no-clickable"
};
function In(e, n, s, r, f, v) {
  const S = de("VNodeRender");
  return e.globalHasSlot("separatorRender") ? (d(), O(S, {
    key: 0,
    vnode: () => e.globalRenderSlot("separatorRender", {})
  }, null, 8, ["vnode"])) : (d(), P("div", kn));
}
const we = /* @__PURE__ */ fe(xn, [["render", In]]), wn = Q({
  name: "ContextSubMenu",
  components: {
    ContextMenuItem: Pe,
    ContextMenuSeparator: we,
    ContextMenuIconRight: Ve
  },
  props: {
    /**
     * Items from options
     */
    items: {
      type: Object,
      default: null
    },
    /**
     * Max width for this submenu
     */
    maxWidth: {
      type: [String, Number],
      default: 0
    },
    /**
     * Min width for this submenu
     */
    minWidth: {
      type: [String, Number],
      default: 0
    },
    /**
     * Specifies should submenu adjust it position
     * when the menu exceeds the screen. The default is true
     */
    adjustPosition: {
      type: Boolean,
      default: !0
    },
    /**
     * Menu direction
     */
    direction: {
      type: String,
      default: "br"
    }
  },
  setup(e) {
    const n = _("menuContext"), s = _("globalOptions"), r = _("globalHasSlot"), f = _("globalRenderSlot"), { zIndex: v, getParentWidth: S, getParentHeight: i, getZoom: m } = n, { adjustPosition: b } = se(e), t = I(), x = I(), $ = I(), w = I(), E = [], L = _("globalSetCurrentSubMenu"), M = [];
    let o = null, a = 0;
    function g() {
      o && o.blur();
    }
    function C(u, h) {
      if (u) {
        for (let T = h !== void 0 ? h : 0; T < M.length; T++)
          if (!M[T].isDisabledOrHidden()) {
            R(T);
            break;
          }
      } else
        for (let T = h !== void 0 ? h : M.length - 1; T >= 0; T--)
          if (!M[T].isDisabledOrHidden()) {
            R(T);
            break;
          }
    }
    function R(u) {
      if (o && g(), u !== void 0 && (o = M[Math.max(0, Math.min(u, M.length - 1))]), !!o && (o.focus(), te.value)) {
        const h = o.getElement();
        h && (p.value = Math.min(Math.max(-B.value, -h.offsetTop - h.offsetHeight + U.value), 0));
      }
    }
    function c() {
      L(y);
    }
    const y = {
      isTopLevel: () => n.getParentContext() === null,
      closeSelfAndActiveParent: () => {
        const u = z.getParentContext();
        if (u) {
          u.closeOtherSubMenu();
          const h = u.getSubMenuInstanceContext();
          if (h)
            return h.focusCurrentItem(), !0;
        }
        return !1;
      },
      closeCurrentSubMenu: () => {
        var u;
        return (u = z.getParentContext()) == null ? void 0 : u.closeOtherSubMenu();
      },
      moveCurrentItemFirst: () => C(!0),
      moveCurrentItemLast: () => C(!1),
      moveCurrentItemDown: () => C(!0, o ? M.indexOf(o) + 1 : 0),
      moveCurrentItemUp: () => C(!1, o ? M.indexOf(o) - 1 : 0),
      focusCurrentItem: () => R(),
      openCurrentItemSubMenu: () => o ? o == null ? void 0 : o.showSubMenu() : !1,
      triggerCurrentItemClick: (u) => o == null ? void 0 : o.click(u)
    };
    let W = !1, D = !1;
    const z = {
      zIndex: v + 1,
      container: n.container,
      adjustPadding: s.value.adjustPadding || N.defaultAdjustPadding,
      getParentWidth: () => {
        var u;
        return ((u = x.value) == null ? void 0 : u.offsetWidth) || 0;
      },
      getParentHeight: () => {
        var u;
        return ((u = x.value) == null ? void 0 : u.offsetHeight) || 0;
      },
      getParentX: () => k.value.x,
      getParentY: () => k.value.y,
      getParentAbsX: () => x.value ? J(x.value, n.container) : 0,
      getParentAbsY: () => x.value ? q(x.value, n.container) : 0,
      getPositon: () => [0, 0],
      getZoom: () => s.value.zoom || N.defaultZoom,
      addOpenedSubMenu(u) {
        E.push(u);
      },
      closeOtherSubMenu() {
        E.forEach((u) => u()), E.splice(0, E.length), L(y);
      },
      checkCloseOtherSubMenuTimeOut() {
        return a ? (clearTimeout(a), a = 0, !0) : !1;
      },
      closeOtherSubMenuWithTimeOut() {
        a = setTimeout(() => {
          a = 0, this.closeOtherSubMenu();
        }, 200);
      },
      addChildMenuItem: (u, h) => {
        h === void 0 ? M.push(u) : M.splice(h, 0, u);
      },
      removeChildMenuItem: (u) => {
        M.splice(M.indexOf(u), 1), u.getSubMenuInstance = () => {
        };
      },
      markActiveMenuItem: (u, h = !1) => {
        g(), o = u, h && R();
      },
      markThisOpenedByKeyBoard: () => {
        W = !0;
      },
      isOpenedByKeyBoardFlag: () => W ? (W = !1, !0) : !1,
      isMenuItemDataCollectedFlag: () => D,
      getElement: () => x.value || null,
      getParentContext: () => n,
      getSubMenuInstanceContext: () => y
    };
    Y("menuContext", z);
    const ee = {
      getChildItem: (u) => M[u],
      getMenuDimensions: () => t.value ? {
        width: t.value.offsetWidth,
        height: t.value.offsetHeight
      } : { width: 0, height: 0 },
      getSubmenuRoot: () => t.value,
      getMenu: () => x.value,
      getScrollValue: () => p.value,
      setScrollValue: (u) => p.value = u,
      getScrollHeight: () => B.value,
      getMaxHeight: () => U.value,
      getPosition: () => k.value,
      setPosition: (u, h) => {
        k.value.x = u, k.value.y = h;
      }
    }, H = _("menuItemInstance", void 0);
    H && (H.getSubMenuInstance = () => ee);
    const p = I(0), B = I(0);
    function K(u) {
      u ? p.value = Math.min(Math.max(p.value - 50, -B.value), 0) : p.value = Math.min(p.value + 50, 0);
    }
    function X(u) {
      u.preventDefault(), u.stopPropagation(), K(u.deltaY > 0);
    }
    function ne(u) {
      s.value.mouseScroll && (u.preventDefault(), u.stopPropagation(), K(u.deltaY > 0));
    }
    const te = I(!1), k = I({ x: 0, y: 0 }), U = I(0);
    return ge(() => {
      const u = n.getPositon();
      k.value = {
        x: (u[0] ?? s.value.xOffset ?? 0) / m(),
        y: (u[1] ?? s.value.yOffset ?? 0) / m()
      }, L(y), me(() => {
        var T, Oe;
        const h = x.value;
        if (h && $.value) {
          const { container: oe } = n, be = (S == null ? void 0 : S()) ?? 0, $e = (i == null ? void 0 : i()) ?? 0, ve = typeof n.adjustPadding == "number" ? n.adjustPadding : ((T = n.adjustPadding) == null ? void 0 : T.x) ?? 0, he = typeof n.adjustPadding == "number" ? n.adjustPadding : ((Oe = n.adjustPadding) == null ? void 0 : Oe.y) ?? 0, ie = $e > 0 ? he : 0, Ye = document.documentElement.scrollHeight / m(), Ze = document.documentElement.scrollWidth / m(), Xe = Math.min(Ze, oe.offsetWidth), Ce = Math.min(Ye, oe.offsetHeight);
          let Me = J(h, oe), ye = q(h, oe);
          e.direction.includes("l") ? k.value.x -= h.offsetWidth + ve : e.direction.includes("r") ? k.value.x += be + ve : (k.value.x += be / 2, k.value.x -= (h.offsetWidth + ve) / 2), e.direction.includes("t") ? k.value.y -= (h.offsetHeight + he * 2) / m() : e.direction.includes("b") ? k.value.y -= he / m() : (k.value.y += $e / 2 / m(), k.value.y -= (h.offsetHeight + he) / 2 / m()), b.value && me(() => {
            Me = J(h, oe), ye = q(h, oe);
            const Ue = Me + h.offsetWidth - Xe, Re = ye + h.offsetHeight + ie * 2 - Ce;
            if (te.value = Re > 0, B.value = h.offsetHeight - Ce + ie * 2, Ue > 0) {
              const ae = be + h.offsetWidth - ve, re = Me;
              ae > re ? k.value.x -= re : k.value.x -= ae;
            }
            if (te.value) {
              const ae = Re, re = ye;
              ae > re ? k.value.y -= re - ie : k.value.y -= ae - ie, U.value = Ce - ie * 2;
            } else
              U.value = 0;
          });
        }
        h == null || h.focus({
          preventScroll: !0
        }), n.isOpenedByKeyBoardFlag() && C(!0), D = !0;
      });
    }), We(() => {
      H && (H.getSubMenuInstance = () => {
      });
    }), {
      submenuRoot: t,
      menu: x,
      scroll: $,
      options: s,
      zIndex: v,
      constOptions: N,
      scrollValue: p,
      upScrollButton: w,
      overflow: te,
      position: k,
      scrollHeight: B,
      maxHeight: U,
      ...ee,
      globalHasSlot: r,
      globalRenderSlot: f,
      onScroll: K,
      onSubMenuBodyClick: c,
      onMouseWhell: ne,
      onMouseWhellMx: X,
      solveNumberOrStringSize: un
    };
  }
});
const Wn = {
  key: 0,
  class: "mx-context-menu-updown placeholder"
}, Pn = {
  key: 1,
  class: "mx-context-menu-updown placeholder"
}, On = {
  class: "mx-context-menu-scroll",
  ref: "scroll"
};
function $n(e, n, s, r, f, v) {
  const S = de("ContextMenuSeparator"), i = de("ContextSubMenu", !0), m = de("ContextMenuItem"), b = de("ContextMenuIconRight");
  return d(), P("div", {
    ref: "submenuRoot",
    class: Z([
      "mx-context-menu",
      e.options.customClass ? e.options.customClass : "",
      e.options.theme ?? ""
    ]),
    style: Be({
      maxWidth: e.maxWidth ? e.solveNumberOrStringSize(e.maxWidth) : `${e.constOptions.defaultMaxWidth}px`,
      minWidth: e.minWidth ? e.solveNumberOrStringSize(e.minWidth) : `${e.constOptions.defaultMinWidth}px`,
      maxHeight: e.overflow && e.maxHeight > 0 ? `${e.maxHeight}px` : void 0,
      zIndex: e.zIndex,
      left: `${e.position.x}px`,
      top: `${e.position.y}px`
    }),
    "data-type": "ContextSubMenu",
    onClick: n[4] || (n[4] = (...t) => e.onSubMenuBodyClick && e.onSubMenuBodyClick(...t)),
    onWheel: n[5] || (n[5] = (...t) => e.onMouseWhell && e.onMouseWhell(...t))
  }, [
    j("div", {
      class: Z(["mx-context-menu-items"]),
      ref: "menu",
      style: Be({
        top: `${e.scrollValue}px`
      })
    }, [
      F(e.$slots, "default", {}, () => [
        e.overflow && e.options.updownButtonSpaceholder ? (d(), P("div", Wn)) : A("", !0),
        (d(!0), P(Ie, null, De(e.items, (t, x) => (d(), P(Ie, { key: x }, [
          t.hidden !== !0 && t.divided === "up" ? (d(), O(S, { key: 0 })) : A("", !0),
          t.hidden !== !0 && t.divided === "self" ? (d(), O(S, { key: 1 })) : (d(), O(m, {
            key: 2,
            clickHandler: t.onClick ? ($) => t.onClick($) : void 0,
            disabled: typeof t.disabled == "object" ? t.disabled.value : t.disabled,
            hidden: typeof t.hidden == "object" ? t.hidden.value : t.hidden,
            icon: t.icon,
            iconFontClass: t.iconFontClass,
            svgIcon: t.svgIcon,
            svgProps: t.svgProps,
            label: t.label,
            customRender: t.customRender,
            customClass: t.customClass,
            checked: typeof t.checked == "object" ? t.checked.value : t.checked,
            shortcut: t.shortcut,
            clickClose: t.clickClose,
            clickableWhenHasChildren: t.clickableWhenHasChildren,
            preserveIconWidth: t.preserveIconWidth !== void 0 ? t.preserveIconWidth : e.options.preserveIconWidth,
            showRightArrow: t.children && t.children.length > 0,
            hasChildren: t.children && t.children.length > 0,
            rawMenuItem: t,
            onSubMenuOpen: ($) => {
              var w;
              return (w = t.onSubMenuOpen) == null ? void 0 : w.call(t, $);
            },
            onSubMenuClose: ($) => {
              var w;
              return (w = t.onSubMenuClose) == null ? void 0 : w.call(t, $);
            }
          }, qe({ _: 2 }, [
            t.children && t.children.length > 0 ? {
              name: "submenu",
              fn: ce(() => [
                le(i, {
                  items: t.children,
                  maxWidth: t.maxWidth,
                  minWidth: t.minWidth,
                  adjustPosition: t.adjustSubMenuPosition !== void 0 ? t.adjustSubMenuPosition : e.options.adjustPosition,
                  direction: t.direction !== void 0 ? t.direction : e.options.direction
                }, null, 8, ["items", "maxWidth", "minWidth", "adjustPosition", "direction"])
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["clickHandler", "disabled", "hidden", "icon", "iconFontClass", "svgIcon", "svgProps", "label", "customRender", "customClass", "checked", "shortcut", "clickClose", "clickableWhenHasChildren", "preserveIconWidth", "showRightArrow", "hasChildren", "rawMenuItem", "onSubMenuOpen", "onSubMenuClose"])),
          t.hidden !== !0 && (t.divided === "down" || t.divided === !0) ? (d(), O(S, { key: 3 })) : A("", !0)
        ], 64))), 128)),
        e.overflow && e.options.updownButtonSpaceholder ? (d(), P("div", Pn)) : A("", !0)
      ])
    ], 4),
    j("div", On, [
      Ae(j("div", {
        ref: "upScrollButton",
        class: Z("mx-context-menu-updown mx-context-no-clickable up" + (e.overflow && e.scrollValue < 0 ? "" : " disabled")),
        onClick: n[0] || (n[0] = (t) => e.onScroll(!1)),
        onWheel: n[1] || (n[1] = (...t) => e.onMouseWhellMx && e.onMouseWhellMx(...t))
      }, [
        le(b)
      ], 34), [
        [He, e.overflow]
      ]),
      Ae(j("div", {
        class: Z("mx-context-menu-updown mx-context-no-clickable down" + (e.overflow && e.scrollValue > -e.scrollHeight ? "" : " disabled")),
        onClick: n[2] || (n[2] = (t) => e.onScroll(!0)),
        onWheel: n[3] || (n[3] = (...t) => e.onMouseWhellMx && e.onMouseWhellMx(...t))
      }, [
        le(b)
      ], 34), [
        [He, e.overflow]
      ])
    ], 512)
  ], 38);
}
const pe = /* @__PURE__ */ fe(wn, [["render", $n]]), Rn = { class: "mx-menu-ghost-host" }, Ke = /* @__PURE__ */ Q({
  __name: "ContextSubMenuWrapper",
  props: {
    /**
     * Menu options
     */
    options: {
      type: Object,
      default: null
    },
    /**
     * Show menu?
     */
    show: {
      type: Object,
      default: null
    },
    /**
     * Current container, For calculation only
     */
    container: {
      type: Object,
      default: null
    },
    /**
     * Make sure is user set the custom container.
     */
    isFullScreenContainer: {
      type: Boolean,
      default: !0
    }
  },
  emits: ["close", "closeAnimFinished"],
  setup(e, { expose: n, emit: s }) {
    const r = e, f = s, v = Je(), S = I(), {
      options: i,
      show: m,
      container: b
    } = se(r);
    ge(() => {
      m.value && $();
    }), We(() => {
      M();
    }), Te(m, (c) => {
      c ? $() : (Fe(t), M());
    });
    const t = {
      closeMenu: w,
      isClosed: E,
      getMenuRef: () => S.value,
      getMenuDimensions: () => {
        var c;
        return ((c = S.value) == null ? void 0 : c.getMenuDimensions()) ?? { width: 0, height: 0 };
      }
    };
    let x = !1;
    function $() {
      L(), nn(t);
    }
    function w(c) {
      x = !0, f("close", c), i.value.menuTransitionProps || f("closeAnimFinished"), Fe(t);
    }
    function E() {
      return x;
    }
    function L() {
      setTimeout(() => {
        document.addEventListener("click", C, !0), document.addEventListener("contextmenu", C, !0), document.addEventListener("scroll", g, !0), !r.isFullScreenContainer && b.value && b.value.addEventListener("scroll", g, !0), i.value.keyboardControl !== !1 && document.addEventListener("keydown", a);
      }, 50);
    }
    function M() {
      document.removeEventListener("contextmenu", C, !0), document.removeEventListener("click", C, !0), document.removeEventListener("scroll", g, !0), !r.isFullScreenContainer && b.value && b.value.removeEventListener("scroll", g, !0), i.value.keyboardControl !== !1 && document.removeEventListener("keydown", a);
    }
    const o = I();
    Y("globalSetCurrentSubMenu", (c) => o.value = c);
    function a(c) {
      var W, D, z, ee, H, p, B, K, X, ne, te, k, U;
      let y = !0;
      switch (c.key) {
        case "Escape": {
          ((W = o.value) == null ? void 0 : W.isTopLevel()) === !1 ? (D = o.value) == null || D.closeCurrentSubMenu() : w();
          break;
        }
        case "ArrowDown":
          (z = o.value) == null || z.moveCurrentItemDown();
          break;
        case "ArrowUp":
          (ee = o.value) == null || ee.moveCurrentItemUp();
          break;
        case "Home":
          (H = o.value) == null || H.moveCurrentItemFirst();
          break;
        case "End":
          (p = o.value) == null || p.moveCurrentItemLast();
          break;
        case "ArrowLeft": {
          (B = o.value) != null && B.closeSelfAndActiveParent() || (X = (K = i.value).onKeyFocusMoveLeft) == null || X.call(K);
          break;
        }
        case "ArrowRight":
          (ne = o.value) != null && ne.openCurrentItemSubMenu() || (k = (te = i.value).onKeyFocusMoveRight) == null || k.call(te);
          break;
        case "Enter":
          (U = o.value) == null || U.triggerCurrentItemClick(c);
          break;
        default:
          y = !1;
          break;
      }
      y && o.value && (c.stopPropagation(), c.preventDefault());
    }
    function g() {
      i.value.closeWhenScroll !== !1 && w();
    }
    function C(c) {
      R(c.target, c);
    }
    function R(c, y) {
      var W, D;
      for (; c; ) {
        if (c.classList && c.classList.contains("mx-menu-host"))
          return;
        c = c.parentNode;
      }
      i.value.clickCloseOnOutside !== !1 ? (M(), w()) : (D = (W = i.value).onClickOnOutside) == null || D.call(W, y);
    }
    return Y("globalOptions", i), Y("globalCloseMenu", w), Y("globalIsFullScreenContainer", r.isFullScreenContainer), Y("globalHasSlot", (c) => v[c] !== void 0), Y("globalRenderSlot", (c, y) => F(v, c, { ...y }, () => [ue("span", "Render slot failed")], !1)), Y("menuContext", {
      zIndex: i.value.zIndex || N.defaultZindex,
      container: b.value,
      adjustPadding: { x: 0, y: 0 },
      getParentAbsY: () => i.value.x,
      getParentAbsX: () => i.value.y,
      getZoom: () => i.value.zoom || N.defaultZoom,
      getParentX: () => 0,
      getParentY: () => 0,
      getParentWidth: () => 0,
      getParentHeight: () => 0,
      getPositon: () => [i.value.x, i.value.y],
      closeOtherSubMenuWithTimeOut: () => {
      },
      checkCloseOtherSubMenuTimeOut: () => !1,
      addOpenedSubMenu: () => {
      },
      closeOtherSubMenu: () => {
      },
      getParentContext: () => null,
      getSubMenuInstanceContext: () => null,
      getElement: () => null,
      addChildMenuItem: () => {
      },
      removeChildMenuItem: () => {
      },
      markActiveMenuItem: () => {
      },
      markThisOpenedByKeyBoard: () => {
      },
      isOpenedByKeyBoardFlag: () => !1,
      isMenuItemDataCollectedFlag: () => !1
    }), n(t), (c, y) => (d(), P("div", Rn, [
      l(i).menuTransitionProps ? (d(), O(Ee, xe({
        key: 0,
        appear: ""
      }, l(i).menuTransitionProps, {
        onAfterLeave: y[0] || (y[0] = (W) => f("closeAnimFinished"))
      }), {
        default: ce(() => [
          l(m) ? (d(), O(pe, {
            key: 0,
            ref_key: "submenuInstance",
            ref: S,
            class: "mx-menu-host",
            items: l(i).items,
            adjustPosition: l(i).adjustPosition,
            maxWidth: l(i).maxWidth || l(N).defaultMaxWidth,
            minWidth: l(i).minWidth || l(N).defaultMinWidth,
            direction: l(i).direction || l(N).defaultDirection
          }, {
            default: ce(() => [
              F(c.$slots, "default")
            ]),
            _: 3
          }, 8, ["items", "adjustPosition", "maxWidth", "minWidth", "direction"])) : A("", !0)
        ]),
        _: 3
      }, 16)) : l(m) ? (d(), O(pe, {
        key: 1,
        ref_key: "submenuInstance",
        ref: S,
        class: "mx-menu-host",
        items: l(i).items,
        adjustPosition: l(i).adjustPosition,
        maxWidth: l(i).maxWidth || l(N).defaultMaxWidth,
        minWidth: l(i).minWidth || l(N).defaultMinWidth,
        direction: l(i).direction || l(N).defaultDirection
      }, {
        default: ce(() => [
          F(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["items", "adjustPosition", "maxWidth", "minWidth", "direction"])) : A("", !0)
    ]));
  }
});
const Bn = Q({
  name: "ContextMenu",
  emits: ["update:show", "close"],
  props: {
    /**
     * Menu options
     */
    options: {
      type: Object,
      default: null
    },
    /**
     * Show menu?
     */
    show: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, n) {
    const {
      options: s,
      show: r
    } = se(e), f = I(null);
    return n.expose({
      closeMenu: () => n.emit("update:show", !1),
      isClosed: () => !r.value,
      getMenuRef: () => {
        var v;
        return (v = f.value) == null ? void 0 : v.getMenuRef();
      },
      getMenuDimensions: () => {
        var v;
        return ((v = f.value) == null ? void 0 : v.getMenuDimensions()) ?? { width: 0, height: 0 };
      }
    }), () => {
      const { isNew: v, container: S, eleId: i } = ze(s.value);
      return [
        ue(
          Qe,
          { to: `#${i}` },
          [
            ue(Ke, {
              ref: f,
              options: s,
              show: r,
              container: S,
              isFullScreenContainer: !v,
              onClose: (m) => {
                var b, t;
                n.emit("update:show", !1), n.emit("close"), (t = (b = s.value).onClose) == null || t.call(b, m);
              }
            }, n.slots)
          ]
        )
      ];
    };
  }
}), An = Q({
  name: "ContextMenuGroup",
  props: {
    /**
    * Is this menu disabled? 
    */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
    * Is this menu hidden? 
    */
    hidden: {
      type: Boolean,
      default: !1
    },
    /**
     * Is this menu disabled? 
     */
    clickHandler: {
      type: Function,
      default: null
    },
    /**
     * Menu label
     */
    label: {
      type: String,
      default: ""
    },
    /**
     * Menu icon (for icon class)
     */
    icon: {
      type: String,
      default: ""
    },
    /**
     * Custom icon library font class name.
     * 
     * Only for css font icon, If you use the svg icon, you do not need to use this.
     */
    iconFontClass: {
      type: String,
      default: "iconfont"
    },
    /**
     * Is this menu item checked?
     * 
     * The check mark are displayed on the left side of the icon, so it is not recommended to display the icon at the same time.
     */
    checked: {
      type: Boolean,
      default: !1
    },
    /**
     * Shortcut key text display on the right.
     * 
     * The shortcut keys here are only for display. You need to handle the key events by yourself.
     */
    shortcut: {
      type: String,
      default: ""
    },
    /**
     * Display icons use svg symbol (`<use xlink:href="#icon-symbol-name">`) ， only valid when icon attribute is empty.
     */
    svgIcon: {
      type: String,
      default: ""
    },
    /**
     * The user-defined attribute of the svg tag, which is valid when using `svgIcon`.
     */
    svgProps: {
      type: Object,
      default: null
    },
    /**
     * Should a fixed-width icon area be reserved for menu items without icon. (this item)
     * 
     * Default is true .
     * 
     * The width of icon area can be override with css var `--mx-menu-placeholder-width`.
     */
    preserveIconWidth: {
      type: Boolean,
      default: !0
    },
    /**
     * Show right arrow on this menu?
     */
    showRightArrow: {
      type: Boolean,
      default: !1
    },
    /**
     * Should close menu when Click this menu item ?
     */
    clickClose: {
      type: Boolean,
      default: !0
    },
    /**
     * By default, the submenu will automatically adjust its position to prevent it overflow the container.
     * 
     * If you allow menu overflow containers, you can set this to false.
     * 
     * Default is inherit from `MenuOptions.adjustPosition`  .
     */
    adjustSubMenuPosition: {
      type: Boolean,
      default: void 0
    },
    /**
     * Max width of submenu
     */
    maxWidth: {
      type: [String, Number],
      default: 0
    },
    /**
     * Min width of submenu
     */
    minWidth: {
      type: [String, Number],
      default: 0
    }
  },
  setup(e, n) {
    const s = _("globalOptions"), { adjustSubMenuPosition: r, maxWidth: f, minWidth: v } = se(e), S = typeof r.value < "u" ? r.value : s.value.adjustPosition, i = I(), m = I();
    return n.expose({
      getSubMenuRef: () => i.value,
      getMenuItemRef: () => m.value
    }), () => ue(Pe, {
      ...e,
      ref: m,
      showRightArrow: !0,
      maxWidth: void 0,
      minWidth: void 0,
      adjustSubMenuPosition: void 0,
      hasChildren: typeof n.slots.default !== void 0
    }, n.slots.default ? {
      //Create SubMenu
      submenu: () => ue(pe, {
        ref: i,
        maxWidth: f.value,
        minWidth: v.value,
        adjustPosition: S
      }, {
        default: n.slots.default
      })
    } : void 0);
  }
});
function Hn(e, n, s, r) {
  const f = I(!0), v = ue(Ke, {
    options: e,
    show: f,
    container: n,
    isFullScreenContainer: !s,
    onCloseAnimFinished: () => {
      je(null, n);
    },
    onClose: (S) => {
      var i;
      (i = e.onClose) == null || i.call(e, S), f.value = !1;
    }
  }, r);
  return je(v, n), v.component;
}
function _e(e, n) {
  const s = ze(e);
  return Hn(e, s.container, s.isNew, n).exposed;
}
const Le = {
  /**
   * For Vue install
   * @param app 
   */
  install(e) {
    e.config.globalProperties.$contextmenu = _e, e.component("ContextMenu", Bn), e.component("ContextMenuItem", Pe), e.component("ContextMenuGroup", An), e.component("ContextMenuSperator", we), e.component("ContextMenuSeparator", we), e.component("ContextSubMenu", pe);
  },
  /**
   * Show a ContextMenu in page, same as `this.$contextmenu`
   * 
   * For example:
   * 
   * ```ts
   * onContextMenu(e : MouseEvent) {
   *   //prevent the browser's default menu
   *   e.preventDefault();
   *   //show your menu
   *   ContextMenu.showContextMenu({
   *     x: e.x,
   *     y: e.y,
   *     items: [
   *       { 
   *         label: "A menu item", 
   *         onClick: () => {
   *           alert("You click a menu item");
   *         }
   *       },
   *       { 
   *         label: "A submenu", 
   *         children: [
   *           { label: "Item1" },
   *           { label: "Item2" },
   *           { label: "Item3" },
   *         ]
   *       },
   *     ]
   *   }); 
   * }
   * ```
   * 
   * You can pass customSlots to custom rendering this menu.
   * 
   * For example, custom rendering #itemRender and #separatorRender:
   * ```ts
   *   ContextMenu.showContextMenu({
   *     ...
   *   } as MenuOptions, {
   *     //Use slot in function mode
   *     itemRender: ({ disabled, label, icon, showRightArrow, onClick, onMouseEnter }) => [  h('div', { 
   *       class: 'my-menu-item'+(disabled?' disabled':''),
   *       onMouseenter: onMouseEnter,
   *       onClick: onClick,
   *     }, [
   *       icon ? h('img', { src: icon }) : h('div', { class: 'icon-place-holder' }),
   *       h('span', label),
   *       showRightArrow ? h('span', { class: 'right-arraw' }, '>>') : h('div'),
   *     ]) ],
   *     separatorRender: () => [ h('div', { class: 'my-menu-sperator' }) ]
   *   })
   * ```
   * 
   * @param options The options of ContextMenu
   * @param customSlots You can provide some custom slots to customize the rendering style of the menu. These slots are the same as the slots of component ContextMenu.
   * @returns Menu instance 
   */
  showContextMenu(e, n) {
    return _e(e, n);
  },
  /**
   * Get if there is a menu open now.
   */
  isAnyContextMenuOpen() {
    return en();
  },
  /**
   * Close the currently open menu
   */
  closeContextMenu: Ne,
  //Tools
  transformMenuPosition: tn
}, jn = {}, Fn = {
  class: "mx-menu-bar-icon-menu",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "200",
  height: "200"
}, _n = /* @__PURE__ */ j("path", { d: "M133.310936 296.552327l757.206115 0c19.781623 0 35.950949-16.169326 35.950949-35.950949 0-19.781623-15.997312-35.950949-35.950949-35.950949L133.310936 224.650428c-19.781623 0-35.950949 16.169326-35.950949 35.950949C97.359987 280.383 113.529313 296.552327 133.310936 296.552327z" }, null, -1), Ln = /* @__PURE__ */ j("path", { d: "M890.51705 476.135058 133.310936 476.135058c-19.781623 0-35.950949 16.169326-35.950949 35.950949 0 19.781623 16.169326 35.950949 35.950949 35.950949l757.206115 0c19.781623 0 35.950949-16.169326 35.950949-35.950949C926.467999 492.304384 910.298673 476.135058 890.51705 476.135058z" }, null, -1), En = /* @__PURE__ */ j("path", { d: "M890.51705 727.447673 133.310936 727.447673c-19.781623 0-35.950949 15.997312-35.950949 35.950949s16.169326 35.950949 35.950949 35.950949l757.206115 0c19.781623 0 35.950949-15.997312 35.950949-35.950949S910.298673 727.447673 890.51705 727.447673z" }, null, -1), Dn = [
  _n,
  Ln,
  En
];
function Tn(e, n) {
  return d(), P("svg", Fn, Dn);
}
const Nn = /* @__PURE__ */ fe(jn, [["render", Tn]]), zn = ["onClick", "onMouseenter"], Kn = /* @__PURE__ */ Q({
  __name: "MenuBar",
  props: {
    /**
     * Menu options
     */
    options: {
      type: Object,
      default: null
    }
  },
  setup(e) {
    const n = e, s = I(), r = I(!1), f = I([]), v = I(null);
    function S() {
      r.value = !0;
    }
    function i() {
      r.value = !1;
    }
    ge(() => {
      f.value = n.options.items || [];
    }), Te(() => n.options, () => {
      f.value = n.options.items || [];
    });
    let m = null, b = -1;
    function t() {
      b < f.value.length - 1 ? b++ : b = 0, w(b, f.value[b]);
    }
    function x() {
      b > 0 ? b-- : b = f.value.length - 1, w(b, f.value[b]);
    }
    function $(o) {
      const a = n.options.barPopDirection ?? "bl";
      let g = 0, C = 0;
      return a.startsWith("b") ? C = q(o) + o.offsetHeight : a.startsWith("t") ? C = q(o) : C = q(o) + o.offsetHeight / 2, a.endsWith("l") ? g = J(o) : a.startsWith("r") ? g = J(o) + o.offsetWidth : g = J(o) + o.offsetWidth / 2, { x: g, y: C };
    }
    function w(o, a) {
      var C;
      if (b = o, !a.children)
        return;
      m && (m.closeMenu(), m = null, r.value = !0), v.value = a;
      const g = (C = s.value) == null ? void 0 : C.children[o];
      if (g) {
        const { x: R, y: c } = $(g);
        m = Le.showContextMenu({
          ...n.options,
          items: a.children,
          x: R,
          y: c,
          onKeyFocusMoveLeft() {
            x();
          },
          onKeyFocusMoveRight() {
            t();
          },
          onClose() {
            v.value == a && (r.value = !1, v.value = null), typeof a.onSubMenuClose == "function" && a.onSubMenuClose(void 0);
          }
        }), m && typeof a.onSubMenuOpen == "function" && a.onSubMenuOpen(void 0);
      }
    }
    function E() {
      b = 0;
      const o = s.value;
      if (o) {
        const { x: a, y: g } = $(o);
        m = Le.showContextMenu({
          ...n.options,
          x: a,
          y: g
        });
      }
    }
    function L(o, a) {
      a ? (r.value = !0, w(o, a), a.onClick && (a.clickableWhenHasChildren === !0 && a.children && a.children.length > 0 || !a.children || a.children.length === 0) && a.onClick()) : E();
    }
    function M(o, a) {
      r.value && w(o, a);
    }
    return (o, a) => (d(), P("div", {
      class: Z([
        "mx-menu-bar",
        e.options.theme ?? "",
        e.options.mini ? "mini" : ""
      ]),
      onFocus: S,
      onBlur: i
    }, [
      F(o.$slots, "prefix"),
      e.options.mini ? (d(), P("div", {
        key: 0,
        ref_key: "menuBarContent",
        ref: s,
        class: "mx-menu-bar-content"
      }, [
        j("div", {
          class: "mx-menu-bar-item",
          onClick: a[0] || (a[0] = (g) => L(0, null))
        }, [
          le(Nn)
        ])
      ], 512)) : (d(), P("div", {
        key: 1,
        ref_key: "menuBarContent",
        ref: s,
        class: "mx-menu-bar-content"
      }, [
        (d(!0), P(Ie, null, De(f.value, (g, C) => (d(), P("div", {
          key: C,
          class: Z([
            "mx-menu-bar-item",
            g == v.value ? "active" : ""
          ]),
          onClick: (R) => L(C, g),
          onMouseenter: (R) => M(C, g)
        }, ke(g.label), 43, zn))), 128))
      ], 512)),
      F(o.$slots, "suffix")
    ], 34));
  }
});
export {
  Bn as ContextMenu,
  An as ContextMenuGroup,
  Pe as ContextMenuItem,
  we as ContextMenuSeparator,
  Kn as MenuBar,
  Le as default
};
//# sourceMappingURL=vue3-context-menu.es.js.map
